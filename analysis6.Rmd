---
title: "Untitled"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Data 
## Index
Ennis's three public market indexes: Bloomberg Barclays U.S. Aggregate bonds, Russell 3000 stocks and MSCI ACWI ex-U.S stocks.

```{r acmi_exUS_price}
# https://www.msci.com/end-of-day-data-regional
acmi_exUS <- rio::import(here::here("data", "historyIndex.xls"), skip=6)

acmi_exUS_price <- acmi_exUS %>% slice(1:252) %>% # last few rows are not numbers
  rename("acmi_exUS" = `ACWI ex USA Standard (Large+Mid Cap)`) %>% 
  mutate(acmi_exUS = as.numeric(acmi_exUS)) %>% 
  mutate(Date = str_remove(Date, ",")) %>% 
  mutate(Date = as.Date(Date, "%B%d%Y"),
         month = month(Date), 
         fy = year(Date)) %>% 
  filter(Date >= "2000-06-01") %>% # pension data only has from 2000-06-01
  select(-Date) 

head(acmi_exUS_price)
```

Note: iShares Russell 3000 ETF (IWV) and Vanguard Total Bond Market Index Fund Institutional Shares (VBTIX) uses first day of the month
```{r russell3000_IWV_price}
#iShares Russell 3000 ETF (IWV)
#https://finance.yahoo.com/quote/IWV/history?p=IWV
russell3000_IWV <- rio::import(here::here("data", "IWV.csv"))

russell3000_IWV_price <- russell3000_IWV %>% 
    select(Date, `Adj Close`) %>% # get the Adj Close price
    rename("russell3000_IWV" = `Adj Close`) %>% 
    mutate(month = month(Date), 
           fy = year(Date)) %>% 
    filter(Date < "2021-01-01")

head(russell3000_IWV_price)
```
Not having access to Bloomberg Barclays U.S. Aggregate bonds. Using Vanguard Total Bond Market Index Fund Institutional Shares (VBTIX) instead. 

```{r vanguardBond_VBTIX_price}
#Vanguard Total Bond Market Index Fund Institutional Shares (VBTIX)

vanguardBond_VBTIX <- rio::import(here::here("data", "VBTIX.csv"))

vanguardBond_VBTIX_price <- vanguardBond_VBTIX %>% 
    select(Date, `Adj Close`) %>% 
  filter(Date >= "2000-06-01") %>% # pension data only has from 2000-06-01
  rename("vanguardBond_VBTIX" = `Adj Close`) %>% 
  mutate(month = month(Date), 
         fy = year(Date)) %>% 
  filter(Date < "2021-01-01")

vanguardBond_VBTIX_price
```

## Pension data
```{r}
d <- rio::import(here::here("data", "ppd-data-latest-7.csv"))

pension_data <- d %>% 
  filter(fy >= 2000) %>%
  select(PlanName, PlanFullName, fy, fye, ActLiabilities_GASB, InvestmentReturn_1yr) %>% # Filter some key variables
  mutate(PlanFullName = gsub("\x92", "'", PlanFullName), # Fix plans' full names
         PlanName = gsub("\x92", "'", PlanName)) %>% 
  mutate(fye = ymd(fye),
         month = month(fye))

pension_data 
```
## Joining data

```{r}
index_price <- left_join(vanguardBond_VBTIX_price, russell3000_IWV_price) %>% 
  left_join(acmi_exUS_price) %>% 
  select(Date, month, fy, vanguardBond_VBTIX, russell3000_IWV, acmi_exUS)

# only keep data of the months that Pension data has
pension_month <- unique(pension_data$month)

price_year <- index_price %>% 
  filter(month %in% pension_month) 

price_year
```


```{r}
# Calculate annual returns for the individual securities
stock_returns <- price_year %>%
  data.frame(date = index(.)) %>%
  pivot_longer(cols = 4:6, 
               names_to = "index", 
               values_to = "price") %>%
  arrange(index, month, fy) %>% 
  group_by(index, month) %>%
  mutate(returns = price/lag(price) - 1) %>%
  select(-price, -date) %>%
  pivot_wider(names_from = index, values_from = returns) %>% 
  ungroup()

stock_returns
```

```{r}
#Join pension data with stock returns
pension_index <- pension_data %>% 
  left_join(stock_returns, by = c("fy", "month")) %>% 
  select(-c(PlanFullName, fy, month, ActLiabilities_GASB)) 

#write.csv(pension_index, "pension_index.csv")
head(pension_index)
```
# Alabama Plan
```{r Alabama ERS}
alabama <- pension_index %>% 
  filter(PlanName == "Alabama ERS") 
head(alabama)
```
## Optimizing Portfolio Weights 

Genetic linear model with constraint imposed on coefficients: y ~ b1 * X1 + b2 * X2

Subject to constraints: b1 + b2 = 1; b1 >= 0 AND b2 > 0

Translated into our problem as: InvestmentReturn_1yr ~ b1 * SWTSX  + b2 * VBMFX


```{r best fit}
#document of the package here: https://cran.r-project.org/web/packages/quadprog/quadprog.pdf
y_actual = matrix(alabama$InvestmentReturn_1yr)

x1 = matrix(alabama$acmi_exUS)
x2 = matrix(alabama$russell3000_IWV)
x3 = matrix(alabama$vanguardBond_VBTIX)
x = cbind(x1, x2, x3)

Dmat <- solve(chol(t(x) %*% x))# matrix to be minimized -why using solve(cho())

Amat <- cbind(rep(1,3), diag(3)) # vector define constraint
bvec <- c(1,rep(0,3)) #vector of b coefficient
dvec <- t(y_actual) %*% x  # vector to be minimized

result <- solve.QP(Dmat = Dmat, factorized = TRUE, dvec = dvec, Amat = Amat, bvec = bvec, meq = 1)
result
```


```{r}
#apply the best fit result to alabama

alabama_portfolio_result <- alabama %>% 
  add_column(b1_acmi_exUS = result$solution[1]) %>% 
  add_column(b2_russell3000_IWV = result$solution[2]) %>% 
  add_column(b3_vanguardBond_VBTIX = result$solution[3]) %>% 
  mutate(portfolio_return = acmi_exUS*b1_acmi_exUS + russell3000_IWV*b2_russell3000_IWV + 
           vanguardBond_VBTIX*b3_vanguardBond_VBTIX) %>% 
  
  # sum of square total: (actual value - average of actual value)^2
  mutate(sst = sum((InvestmentReturn_1yr - mean(InvestmentReturn_1yr))^2)) %>% 

  # sum of square error: (actual value - predicted value (i.e. portfolio return))^2
  mutate(sse = sum((InvestmentReturn_1yr - portfolio_return)^2)) %>% 

  # r_squared
  mutate(r_quared = 1 - (sse/sst))

alabama_portfolio_result

```
## Comparison Result 

```{r comparison result}
# Write a function to calculate geomean (Can't believe R does not have a built-in function for this.) 

geo_mean <- function(vector) {
  vector <- vector + 1
  r <- prod(vector)^(1/length(vector)) - 1
  return(r)
}

comparison_result <- alabama_portfolio_result %>% 
  #geomean
  mutate(geomean_actual = geo_mean(InvestmentReturn_1yr)) %>% 
  mutate(geomean_portfolio = geo_mean(portfolio_return)) %>% 
  
  # standard deviation (i.e. risk)
  mutate(sd_actual = sd(InvestmentReturn_1yr)) %>% 
  mutate(sd_portfolio = sd(portfolio_return))

comparison_result
```

# Write a Function to Scale Up

```{r pension_benchmark_comparison function}
pension_benchmark_comparison <- function (planname) {
  plan <- pension_index %>% filter(PlanName == planname)
  
# optimization

  y_actual = matrix(plan$InvestmentReturn_1yr)

  x1 = matrix(plan$acmi_exUS)
  x2 = matrix(plan$russell3000_IWV)
  x3 = matrix(plan$vanguardBond_VBTIX)
  x = cbind(x1, x2, x3)

  Dmat <- solve(chol(t(x) %*% x))# matrix to be minimized -why using solve(chol())
  
  Amat <- cbind(rep(1,3), diag(3)) # vector define constraint
  bvec <- c(1,rep(0,3)) #vector of b coefficient
  dvec <- t(y_actual) %*% x  # vector to be minimized

  result <- solve.QP(Dmat = Dmat, factorized = TRUE, dvec = dvec, Amat = Amat, bvec = bvec, meq = 1)

  plan_result <- plan %>% 
  add_column(b1_acmi_exUS = result$solution[1]) %>% 
  add_column(b2_russell3000_IWV = result$solution[2]) %>% 
  add_column(b3_vanguardBond_VBTIX = result$solution[3]) %>% 
  mutate(portfolio_return = acmi_exUS*b1_acmi_exUS + russell3000_IWV*b2_russell3000_IWV + 
           vanguardBond_VBTIX*b3_vanguardBond_VBTIX) %>% 
    
    # sum of square total: (actual value - average of actual value)^2
    mutate(sst = sum((InvestmentReturn_1yr - mean(InvestmentReturn_1yr))^2)) %>% 
  
    # sum of square error: (actual value - predicted value (i.e. portfolio return))^2
    mutate(sse = sum((InvestmentReturn_1yr - portfolio_return)^2)) %>% 
  
    # r_squared
    mutate(r_quared = 1 - (sse/sst))
  
  #comparison
  comparison_result <- plan_result %>% 
    
  #geomean
  mutate(geomean_actual = geo_mean(InvestmentReturn_1yr)) %>% 
  mutate(geomean_portfolio = geo_mean(portfolio_return)) %>% 
  
  # standard deviation (i.e. risk)
  mutate(sd_actual = sd(InvestmentReturn_1yr)) %>% 
  mutate(sd_portfolio = sd(portfolio_return)) %>% 
   
  
  # standard deviation (i.e. risk)
  mutate(sd_actual = sd(InvestmentReturn_1yr)) %>% 
  mutate(sd_portfolio = sd(portfolio_return))
  return(comparison_result) 
}

```

# Function Applied: California PERF
```{r California}
pension_benchmark_comparison("California PERF")
```

# Function Applied: South Dakota RS
```{r South Dakota RS}
pension_benchmark_comparison("South Dakota RS")
```

# Loop through all plans
```{r}
# Get a list of the first 5 plans
plan_list <- (unique(pension_index$PlanName))[1:5]

# Loop through each plan to produce result
all_plans = list()

for (plan in plan_list) {
  result <- pension_benchmark_comparison(plan)
  all_plans[[plan]] <- result
}

final_result <- bind_rows(all_plans)  
final_result
```
# NOTE: 
test up to 30:
plans NOT run: 7 Connecticut SERS, 11 "Hawaii ERS", 12, 13, 14, 27

```{r}

```



